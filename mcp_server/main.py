# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T03:13:03+00:00



import argparse
import json
import os
from typing import *
from typing import Optional

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity
from fastapi import Path, Query

from models import (
    Embed,
    ExactSpelling,
    OutputFormat,
    OutputFormat8,
    OutputFormat24,
    OutputSRS,
    OutputStyle,
    SortBy,
    SortBy10,
)

app = MCPProxy(
    contact={
        'email': 'geographical.names@gov.bc.ca',
        'name': 'BC Geographical Names Office',
        'url': 'https://www2.gov.bc.ca/gov/content?id=A3C60F17CE934B1ABFA366F28C66E370',
    },
    description='This REST API provides searchable access to information about geographical names in the province of British Columbia, including name status and details about the corresponding geographic feature. \n\nPlease note that you may experience issues when submitting requests to the delivery or test environment if using this [OpenAPI specification](https://github.com/bcgov/api-specs) in other API console viewers.',
    license={
        'name': 'Crown Copyright',
        'url': 'https://www2.gov.bc.ca/gov/content?id=1AAACC9C65754E4D89A118B875E0FBDA',
    },
    title='BC Geographical Names Web Service - REST API',
    version='3.x.x',
    servers=[
        {'description': 'Production', 'url': 'https://apps.gov.bc.ca/pub/bcgnws'},
        {'description': 'Test', 'url': 'https://test.apps.gov.bc.ca/pub/bcgnws'},
        {
            'description': 'Delivery',
            'url': 'https://delivery.apps.gov.bc.ca/pub/bcgnws',
        },
    ],
)


@app.get(
    '/featureCategories',
    description=""" Gets a list of all feature categories used by the BC Geographical Names Information System (BCGNIS).  Note: there are three levels of classification in the BCGNIS feature taxonomy: classes, categories and types.  A type is a subset of a category, and a category is a subset of a class. """,
    tags=['feature_category_management'],
)
def get_feature_categories(
    output_format: OutputFormat = Query(..., alias='outputFormat')
):
    """
    Get all feature categories
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/featureClasses',
    description=""" Gets a list of all feature classes used by the BC Geographical Names Information System (BCGNIS).  Note: there are three levels of classification in the BCGNIS feature taxonomy: classes, categories and types.  A type is a subset of a category, and a category is a subset of a class. """,
    tags=['feature_category_management'],
)
def get_feature_classes(output_format: OutputFormat = Query(..., alias='outputFormat')):
    """
    Get all feature classes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/featureTypes',
    description=""" Gets a list of all feature types used by the BC Geographical Names Information System (BCGNIS).  Note: there are three levels of classification in the BCGNIS feature taxonomy: classes, categories and types.  A type is a subset of a category, and a category is a subset of a class. """,
    tags=['feature_category_management'],
)
def get_feature_types(output_format: OutputFormat = Query(..., alias='outputFormat')):
    """
    Get all feature types
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/features/{featureId}',
    description=""" Get information about the geographical feature with the specified featureId. """,
    tags=['feature_detail_retrieval'],
)
def get_features__feature_id(feature_id: int = Path(..., alias='featureId')):
    """
    Get a feature by its featureId
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/nameAuthorities',
    description=""" Gets a list of all name authorities responsible for naming decisions of the geographical names in the BC Geographical Names Information System (BCGNIS) """,
    tags=['name_authority_query_management'],
)
def get_name_authorities(
    output_format: OutputFormat = Query(..., alias='outputFormat')
):
    """
    Get all name authorities
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/names/changes',
    description=""" Search for information about geographical names which have changed most recently within a specified time window.  Changes may include status cupdates and metadata corrections. """,
    tags=['feature_search_operations', 'name_authority_query_management'],
)
def get_names_changes(
    output_format: OutputFormat8 = Query(..., alias='outputFormat'),
    from_date: int = Query(..., alias='fromDate'),
    to_date: int = Query(..., alias='toDate'),
    feature_class: Optional[str] = Query('*', alias='featureClass'),
    feature_category: Optional[str] = Query('*', alias='featureCategory'),
    feature_type: Optional[str] = Query('*', alias='featureType'),
    sort_by: Optional[SortBy] = Query('name', alias='sortBy'),
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
    embed: Optional[Embed] = None,
    output_style: Optional[OutputStyle] = Query('summary', alias='outputStyle'),
    items_per_page: Optional[int] = Query(20, alias='itemsPerPage'),
    start_index: Optional[int] = Query(1, alias='startIndex'),
):
    """
    Search for names with metadata changes in a given period
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/names/decisions/recent',
    description=""" Search for information about geographical names affected by naming 'decisions' made by the BC Geographical Names Office (naming authority) within the last X days. """,
    tags=['name_authority_query_management', 'feature_search_operations'],
)
def get_names_decisions_recent(
    output_format: OutputFormat8 = Query(..., alias='outputFormat'),
    days: int = 30,
    feature_class: Optional[str] = Query('*', alias='featureClass'),
    feature_category: Optional[str] = Query('*', alias='featureCategory'),
    feature_type: Optional[str] = Query('*', alias='featureType'),
    sort_by: Optional[SortBy] = Query('name', alias='sortBy'),
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
    embed: Optional[Embed] = None,
    output_style: Optional[OutputStyle] = Query('summary', alias='outputStyle'),
    items_per_page: Optional[int] = Query(20, alias='itemsPerPage'),
    start_index: Optional[int] = Query(1, alias='startIndex'),
):
    """
    Search for names affected by recent naming decision
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/names/decisions/year',
    description=""" Search for information about geographical names affected by naming 'decisions' made by the BC Geographical Names Office (naming authority) in a given year. """,
    tags=['name_authority_query_management', 'feature_search_operations'],
)
def get_names_decisions_year(
    output_format: OutputFormat8 = Query(..., alias='outputFormat'),
    year: int = ...,
    feature_class: Optional[str] = Query('*', alias='featureClass'),
    feature_category: Optional[str] = Query('*', alias='featureCategory'),
    feature_type: Optional[str] = Query('*', alias='featureType'),
    sort_by: Optional[SortBy] = Query('name', alias='sortBy'),
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
    embed: Optional[Embed] = None,
    output_style: Optional[OutputStyle] = Query('summary', alias='outputStyle'),
    items_per_page: Optional[int] = Query(20, alias='itemsPerPage'),
    start_index: Optional[int] = Query(1, alias='startIndex'),
):
    """
    Search for names affected by naming decisions in a given year
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/names/inside',
    description=""" Search for information about geographical names that correspond to features within a geographic bounding box.  Various options and filter parameters are available to refine the search. """,
    tags=['feature_search_operations', 'feature_category_management'],
)
def get_names_inside(
    output_format: OutputFormat8 = Query(..., alias='outputFormat'),
    bbox: str = ...,
    feature_class: Optional[str] = Query('*', alias='featureClass'),
    feature_category: Optional[str] = Query('*', alias='featureCategory'),
    feature_type: Optional[str] = Query('*', alias='featureType'),
    sort_by: Optional[SortBy] = Query('name', alias='sortBy'),
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
    embed: Optional[Embed] = None,
    output_style: Optional[OutputStyle] = Query('summary', alias='outputStyle'),
    items_per_page: Optional[int] = Query(20, alias='itemsPerPage'),
    start_index: Optional[int] = Query(1, alias='startIndex'),
):
    """
    Search in a geographic area
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/names/near',
    description=""" Search for information about geographical names that correspond to features within a geographic area defined by a centre point and a radius.  Various options and filter parameters are available to refine the search. """,
    tags=['feature_search_operations', 'feature_category_management'],
)
def get_names_near(
    output_format: OutputFormat8 = Query(..., alias='outputFormat'),
    feature_point: str = Query(..., alias='featurePoint'),
    distance: str = ...,
    feature_class: Optional[str] = Query('*', alias='featureClass'),
    feature_category: Optional[str] = Query('*', alias='featureCategory'),
    feature_type: Optional[str] = Query('*', alias='featureType'),
    sort_by: Optional[SortBy] = Query('name', alias='sortBy'),
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
    embed: Optional[Embed] = None,
    output_style: Optional[OutputStyle] = Query('summary', alias='outputStyle'),
    items_per_page: Optional[int] = Query(20, alias='itemsPerPage'),
    start_index: Optional[int] = Query(1, alias='startIndex'),
):
    """
    Search near to a geographic point
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/names/notOfficial/search',
    description=""" Search for information about unofficial geographical names by the text of the name itself.  Various options and filter parameters are available to refine the search. """,
    tags=['feature_search_operations', 'name_authority_query_management'],
)
def get_names_not_official_search(
    output_format: OutputFormat8 = Query(..., alias='outputFormat'),
    name: str = ...,
    exact_spelling: Optional[ExactSpelling] = Query(0, alias='exactSpelling'),
    feature_class: Optional[str] = Query('*', alias='featureClass'),
    feature_category: Optional[str] = Query('*', alias='featureCategory'),
    feature_type: Optional[str] = Query('*', alias='featureType'),
    sort_by: Optional[SortBy10] = Query('relevance', alias='sortBy'),
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
    embed: Optional[Embed] = None,
    output_style: Optional[OutputStyle] = Query('summary', alias='outputStyle'),
    items_per_page: Optional[int] = Query(20, alias='itemsPerPage'),
    start_index: Optional[int] = Query(1, alias='startIndex'),
):
    """
    Search by name, limit to unofficial names only
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/names/official/search',
    description=""" Search for information about official geographical names by the text of the name itself.  Various options and filter parameters are available to refine the search. """,
    tags=['feature_search_operations', 'name_authority_query_management'],
)
def get_names_official_search(
    output_format: OutputFormat8 = Query(..., alias='outputFormat'),
    name: str = ...,
    exact_spelling: Optional[ExactSpelling] = Query(0, alias='exactSpelling'),
    feature_class: Optional[str] = Query('*', alias='featureClass'),
    feature_category: Optional[str] = Query('*', alias='featureCategory'),
    feature_type: Optional[str] = Query('*', alias='featureType'),
    sort_by: Optional[SortBy10] = Query('relevance', alias='sortBy'),
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
    embed: Optional[Embed] = None,
    output_style: Optional[OutputStyle] = Query('summary', alias='outputStyle'),
    items_per_page: Optional[int] = Query(20, alias='itemsPerPage'),
    start_index: Optional[int] = Query(1, alias='startIndex'),
):
    """
    Search by name, limit to official names only
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/names/search',
    description=""" Search for information about geographical names by the text of the name itself.  The response will include both official and unofficial names.  Various options and filter parameters are available to refine the search. """,
    tags=['feature_search_operations', 'name_authority_query_management'],
)
def get_names_search(
    output_format: OutputFormat8 = Query(..., alias='outputFormat'),
    name: str = ...,
    exact_spelling: Optional[ExactSpelling] = Query(0, alias='exactSpelling'),
    feature_class: Optional[str] = Query('*', alias='featureClass'),
    feature_category: Optional[str] = Query('*', alias='featureCategory'),
    feature_type: Optional[str] = Query('*', alias='featureType'),
    sort_by: Optional[SortBy10] = Query('relevance', alias='sortBy'),
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
    embed: Optional[Embed] = None,
    output_style: Optional[OutputStyle] = Query('summary', alias='outputStyle'),
    items_per_page: Optional[int] = Query(20, alias='itemsPerPage'),
    start_index: Optional[int] = Query(1, alias='startIndex'),
):
    """
    Search by name
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/names/{nameId}.{outputFormat}',
    description=""" Get information about the geographical name with the specified nameId. """,
    tags=['name_authority_query_management', 'feature_detail_retrieval'],
)
def get_names__name_id__output_format(
    name_id: int = Path(..., alias='nameId'),
    output_format: OutputFormat24 = Path(..., alias='outputFormat'),
):
    """
    Get a name by its nameId
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
